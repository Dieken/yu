# 单字拆分

先前说过，拆字，就是把汉字按照一定的规则，拆成唯一的字根组合。这个过程如同拼图一般，大多数时候，是非常直观而自然的。

::: tip 例

`部` = `立` `口` `阝` 

`先` = `⺧` `儿`  

`国` = `囗` `王` `丶`  

`鴿` = `合` `鳥`

`琴` = `王` `王` `人` `丶` `乛`  

`李` = `木` `子`  
:::

这种将字拆成直观的、分离的部件的方法，足以应付大部分汉字的拆分了。但在实际使用中，遇到这个问题：一个独体字，本身不是字根，怎么办？这时候，我们要把它继续拆成更小的字根甚至笔划。

::: tip 例

`戋`这个字，我们可以继续将它拆成`一`和`戈`。查字根图可知，`一`和`戈`正好是两个字根，拆字成功。  

`丸`这个字，我们可以继续将它拆成`九`和`丶`。查字根图可知，`九`和`丶`正好是两个字根，拆字成功。  

`朱`这个字，我们可以继续将它拆成`牛`和`八`。查字根图可知，`牛`和`八`正好是两个字根，拆字成功。  

:::

有时候，独体字的拆分不是很直观。比如`再`拆成`王冂`两个字根。遇到此类字时的拆分，往往需要一些经验和练习。所以当你遇到不会拆的字时，应该主动查询它的编码，及时学习。

更麻烦的情况是，**一个字好像有几种拆分方法**。

::: tip 例

`井`，可以拆`二{介下}`，也可以拆`一廾`。  

`单`可以拆成`丷日十`也可以拆成`丷冂丰`。  

`兰`可以拆成`䒑二`也可以拆成`丷三`。  
:::

这种一字多拆的情况，任何形码中，都是希望避免的。因为一字多拆，会造成极大的不确定性，并造成编码的混乱。

前辈输入法的拆字规则，一般都有诸如「直观」、「符合笔顺」、「取大」等设置。但是优先级往往不够明确，很多拆分方法并不符合规则，存在不少特例。在常用字范围内，还可以通过大量练习来完成记忆，但到了大字集，规则不明确、规则相矛盾，都是造成检字困难的因素。

宇浩输入法总结了拆字规则，并且不断自我审视每一个拆分是否符合规则。通过大量的努力，明确了一套优先级系统。使每一个汉字，都有唯一的拆分方案，消除了不确定性。

当然，汉字不是完全可以量化的，不同字形下，也会出现不同的拆分可能。除了良好的定义外，有时候比例原则也很重要。尤其在大字集上，追求单一拆分方法会扭曲汉字直观性，不能兼顾不同字形，让使用者需要大量尝试才能找到想要的字，这违背了大字集检字的初衷。因此，对于大字集，也会设置兼容拆分和容错码。

::: info 拆字优先级

「宇浩」拆字规则，按优先级排序如下：

1. 字根最少
1. 符合笔顺
1. 结构完整
1. 散连交断
1. 字根取大

以上优先级，还可以高度归纳为：**少顺整散连交断大**。
:::

取根时，如果有多种不同的拆分方式，则按**优先级从高到低**依次检查以上规则，选取符合条件的，排除不满足的，最终得到唯一的拆分方案。因此，某种意义上来说，宇浩输入法的拆分规则，其实是一种「比较和淘汰」的排除法，[后文中会展示这些步骤的机器实现](#机器实现)。

::: info 注意

在进行拆分前，首先需要「确认」某个字根到底存不存在，是否合规，也就是检查字根的「内在属性」。比如`土` `士`，两横的长度直接决定了字根的异同。  

其次需要检查一些「拆分禁手」，比如`王`中间如果被笔画「穿心」，这是不被允许的。禁手有：散件不分割、竖向不包夹、横间不穿心。  

对这两点的讨论作为进阶内容，于此处跳过。若有兴趣，可以在后续章节 《进阶讨论》中阅读。
:::

以下为拆分规则详细介绍：

## 字根最少

字根最少，意思是拆分一个字时，应该使得字根的数量最少。保证字根数量最少，是第一优先级最高的规则。

## 符合笔顺

符合笔顺，指的是字根的每一笔，完全符合原汉字的笔顺。我们要使得完全合笔顺的字根尽量多。

符合笔顺的优先级低于字根最少。

::: tip 例

`国`如果完全符合笔顺，应该拆成`冂王丶一`，是四个字根。但拆成`囗王丶`，只用三个字根就够了。因为「少」优先级高于「顺」，所以应该拆成`囗王丶`。
:::

## 结构完整

结构完整，指的是`囗日目勹冂匚コ凵`等存在全包围和半包围结构的字根不拆散。

这个原则的设置，是为了不过分破坏汉字的整体性和直观性。

::: tip 例

`昜`拆`日一勹彡`不拆`日丆𠃌彡`。

`万`拆成`一勹`而非`{一丿}乛`。

`单`可以拆成`丷日十`也可以拆成`丷冂丰`。两者都是三根，都完全「符合笔顺」。因为包围结构不拆散，故而`单`拆成`丷日十`。

`免`可以拆成`⺈口儿`也可以拆成`⺈冂尢`。两者都是三根，都完全「符合笔顺」。因为包围结构不拆散，故而`免`拆成`⺈口儿`。
:::

注意，拆分的优先级需要得到贯彻。

::: tip 例

`匹`拆`兀乚`而不拆`匚儿`。因为前者完全符合笔顺，而「符合笔顺」的优先级更高。
:::

## 散连交断

「散·连·交·断」，是汉字部首或笔画的四种状态。

- 字根离散，指的是两个字根互相分离。比如`部`中的`立口阝`，便是三个分离的字根。
- 字根相连，指的是两个字根互相连接。比如`美`拆为`𦍌大`，这两个字根是相连的。
- 字根相交，指的是两个字根互相交叉。比如`再`拆成`王冂`两个字根，便是相交的。
- 笔划断开，指的是一个笔划断开。比如`我`拆成`丿扌戈`三个字根，其中的`扌`和`戈`两根的横本是一笔写成，但我们将横画断开。

「散连交断」，优先级依次下降，但都排在「字根最少」「符合笔顺」「结构完整」之後。

::: tip 例
`兰`可以拆成`䒑二`也可以拆成`丷三`。观察到，`䒑`的两点是同一横黏在一起的。拆成`丷三`，則兩個字根相連，拆成`䒑二`則兩個字根分散。後者符合「能散不连」。  

`开`可以拆成`一廾`也可以拆成`二{介下}`。观察到，第一种拆法字根相连，第二种拆法字根相交。故而拆成`一廾`符合「能连不交」。  

`果`拆作`日木`，不拆成`田木`，这是因为后者将中间的竖断开了。因为「字根相交」的优先级高于「笔画断开」，`果`应当拆成`日木`。  

`我`拆作`丿扌戈`，不拆成`丿扌乚丿丶`。虽然前者将中间的横断开了，但因为「字根最少」的优先级大于「笔画断开」，我们选择只有三根的`丿扌戈`。  

`熏`拆作`千黑`，不拆成`千囗丷二灬`。虽然前者将中间的竖断开了，但因为「字根最少」的优先级大于「笔画断开」，我们选择只有两根的`千黑`。  
:::

## 字根取大

字根取大，指的是按照笔顺拆字时：

- 让完全符合笔顺的字根尽可能地大。也就是就算做不到完全合笔顺，也要做到局部合笔顺。只要其中某个字根多写一笔仍然符合笔顺，就多写一笔。
- 让非歪斜根尽可能地大。
- 让首笔靠前的字根尽可能地大。

第一条的存在，是为了防止笔画过于交织而导致拆分方案不直观。

::: tip 例
这里以`妻`字举例，`妻`可以拆分为`十彐女``キコ女`甚至`龶乛女`。我们按顺序检查规则，发现：

- 三者都是三根，都不完全符合笔顺，都存在相交。
- 我们最后检查「字根取大」规则。我们发现，前两个字根是穿插书写的。`キコ女`的拆法中，前两根分成四部分写成。`十彐女``龶乛女`，前两根只分成三部分写成，故而`キコ女`淘汰。
- `十彐女`中，完全合笔顺的字根`彐`写了三笔。而`龶乛女`中，完全合笔顺的字根`乛`只有一笔。
- `十彐女`胜出。
:::

第二条只有一种场合会出现，那就是部分字根在做偏旁的时候，由于书法的考虑，会有「竖变撇」的变化。如：`千`字根的`丨`变成`丿`，`干`字根的`丨`变成`丿`，称为「歪斜根」。我们应当对非歪斜根取大。

::: tip 例
`失`拆`丿夫`而不拆`牛乀`，因为`牛`的一竖是撇。故而对`夫`取大。

`井`拆`二{介下}`而不拆`キ丨`，因为因为`キ`的一竖是撇。故而对`{介下}`取大。

`缓`拆`纟爪干又`而不拆`纟爪二夂`。虽然前者`干`的竖是撇，但后者出现了「字根相交」。根据规则优先级，「字根相交」低于「字根相连」，故而拆为`纟爪干又`。
:::

第三条最为常见，「让首笔靠前的字根尽可能地大」是一个兜底原则，可以保证最终只有一个候选方案能够胜出。因此，它的优先级必然是所有拆字规则中最低的。

::: tip 例
`井`拆成`二{齐下}`，而不拆成`一廾`，因为「字根取大」原则。让首笔靠前的字根的笔划数尽量地多，这里，`二`的笔画数大于`一`。  

`美`拆为`䒑土大`，而不拆成`丷王大`，因为「字根取大」原则。让首笔靠前的字根的笔划数尽量地多，这里，`䒑`的笔画数大于`丷`。
:::

## 拆字举例

实际拆字时，如果你感觉拆分方法不唯一，那么可以用以下方法找到最优解：

- 列出所有可能的候选拆分方案。
- 依照「少顺整散连交断大」的规则顺序，依次比较各个候选拆分。
- 如果所有的候选拆分都不满足本条规则，则进入下条规则。
- 如果部分的候选拆分满足本条规则，则该部分的候选拆分方案进入下条规则。
- 直到只有一个候选拆分方案胜出。

以下通过部分例字来说明拆分规则：

::: tip 例

1. 一例：亷。候选拆分`亠丷厂彐〢八`和`立丿彐〢八`。
   - `亠丷厂彐〢八`六根，`立丿彐〢八`五根。后者字根最少，直接胜出。
2. 又一例：重。候选拆分`丿車一`和`千里`。
   - `千里`是两根，满足「字根最少」，直接虽然中间一竖断开，但依然胜出。
3. 又一例：盡。候选拆分`コ土灬皿``乛龶灬皿``彐丄灬皿``{聿上}一灬皿`四种。
   - 都是四根，同时满足「字根最少」。
   - `コ土灬皿`不符合笔顺，其他三者都完全符合笔顺。淘汰`コ土灬皿`。
   - 上半部分都出现字根相交情况。
   - 都不适用「结构合理」。
   - 进入兜底规则「字根取大」。根据规则，只要其中某个字根多写一笔仍然符合笔顺，就多写一笔。观察到，`{聿上}一灬皿`的第一根一共写了四笔，故而胜出。
4. 又一例：曱 yuē甴 yóu。
   - `曱`按笔顺取大，故而是`日丨`。
   - `甴`，候选拆分为`日丨``囗丄`。两者都是两根，都未破坏包围结构，都出现了「交」。最后查看取大原则。因为先写竖，再写中间的一横，为了让完全符合笔顺的部件尽可能地大，我们取`丄`。最后`囗丄`胜出。
:::

上面的例子逻辑虽比较复杂，但是最终的结果还是非常直观的。在宇浩输入法中，大多数的时候，直观的拆分方法往往也是符合规则的。

## 机器实现

这里释出宇浩拆分规则的伪代码，用以展示使用计算机程序来实现拆分筛选的算法逻辑。注意，宇浩的拆分规则是**淘汰性**而非**引导性**的，故而算法的前置条件是已经拥有了若干的候选拆分，在此基础上，程序可以筛选出最满足宇浩拆分规则的唯一拆分。

假设某个汉字存在`N`个候选拆分，记为 `divs = {div_i | i in [1, 2, ..., N]}`。每个拆分都是字根的**有序**集合，记为 `div = {root_i | i in [1, 2, ..., M]}`，有以下属性：

- `div.len: int` 字根个数
- `div.bishun: Booleann` 字根是否完全合笔顺
- `div.san: Boolean` 字根是否分散
- `div.lian: Boolean` 字根是否相连
- `div.jiao: Boolean` 字根是否相交
- `div.duan: Boolean` 字根是否断开

注意：`div.san`, `div.lian`, `div.jiao`, `div`,`duan` 中有且只有一个是 `True`。

以下伪代码会从`N`个候选拆分`divs = {div_i | i in [1, 2, ..., N]}` 中选出最优拆分：

```python
# 字根最少
for div_i in divs:
    # 移除字根数量不是最少的候选拆分
    if div_i.len != min([i.len for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 符合笔顺
for div_i in divs:
    # 存在完全符合笔顺的拆分时，移除不完全符合笔顺的候选拆分
    if div_i.bishun != max([i.bishun for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 结构完整
root_completeness_score = {
    囗：2,
    日：2,
    目：2,
    田：2,
    冂：1,
    勹：1,
    匚：1,
    凵：1,
    コ：1,
    其他：0,
}  # 包围结构得分更高
for div_i, div_j in permutation(divs, 2):  # 俩俩取候选拆分比较
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # 非共同字根中有包围结构的保留
    if unique_i.map(root_completeness_score) < unique_j.map(root_completeness_score):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 字根分散
for div_i in divs:
    # 存在散的拆分时，移除不散的候选拆分
    if div_i.san != max([i.san for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 字根相连
for div_i in divs:
    # 存在连的拆分时，移除不连的候选拆分
    if div_i.lian != max([i.lian for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 字根相交
for div_i in divs:
    # 存在交的拆分时，移除不交的候选拆分
    if div_i.jiao != max([i.jiao for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 字根断开
# 断属性为散连交的补集，故不用再进行判断

# 字根取大之一
# 让完全符合笔顺的部件尽可能地大
for div_i, div_j in permutation(divs, 2):  # 俩俩取候选拆分比较
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # root_bishun_score(div) 是局部拆分中完全符合笔顺的字根数量
    # 非共同字根中，完全符合笔顺的字根数量多的保留
    if root_bishun_score(unique_i) < root_bishun_score(unique_j):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 字根取大之二
# 让非歪斜根尽可能地大
for div_i, div_j in permutation(divs, 2):  # 俩俩取候选拆分比较
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # leaning_root_strokes(div) 是局部拆分中歪斜根的笔画数
    # 非共同字根中，非歪斜根笔画多的保留
    if leaning_root_strokes(unique_i) > leaning_root_strokes(unique_j):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候选，则停止判断

# 字根取大之三
# 让首笔靠前的字根尽可能地大
for div_i, div_j in permutation(divs, 2):  # 俩俩取候选拆分比较
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # root_i.strokes.len 是字根的笔画数
    # 非共同字根中，靠前的字根笔画多的保留
    for root_i, root_j in zip(unique_i, unique_j):  # 俩俩取字根比较
        if root_i.strokes.len < root_j.strokes.len:
            divs.remove(div_i)

# 到此，必然只剩下唯一的拆分候选，即为最终拆分
```
