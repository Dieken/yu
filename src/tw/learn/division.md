# 單字拆分

先前說過，拆字，就是把漢字按照一定的規則，拆成唯一的字根組合。這個過程如同拼圖一般，大多數時候，是非常直觀而自然的。

::: tip 例

`部` = `立` `口` `阝` 

`先` = `⺧` `兒`  

`國` = `囗` `王` `丶`  

`鴿` = `合` `鳥`

`琴` = `王` `王` `人` `丶` `乛`  

`李` = `木` `子`  
:::

這種將字拆成直觀的、分離的部件的方法，足以應付大部分漢字的拆分了。但在實際使用中，遇到這個問題：一個獨體字，本身不是字根，怎麼辦？這時候，我們要把它繼續拆成更小的字根甚至筆劃。

::: tip 例

`戔`這個字，我們可以繼續將它拆成`一`和`戈`。查字根圖可知，`一`和`戈`正好是兩個字根，拆字成功。  

`丸`這個字，我們可以繼續將它拆成`九`和`丶`。查字根圖可知，`九`和`丶`正好是兩個字根，拆字成功。  

`朱`這個字，我們可以繼續將它拆成`牛`和`八`。查字根圖可知，`牛`和`八`正好是兩個字根，拆字成功。  

:::

有時候，獨體字的拆分不是很直觀。比如`再`拆成`王冂`兩個字根。遇到此類字時的拆分，往往需要一些經驗和練習。所以當你遇到不會拆的字時，應該主動查詢它的編碼，及時學習。

更麻煩的情況是，**一個字好像有幾種拆分方法**。

::: tip 例

`井`，可以拆`二{介下}`，也可以拆`一廾`。  

`單`可以拆成`丷日十`也可以拆成`丷冂豐`。  

`蘭`可以拆成`䒑二`也可以拆成`丷三`。  
:::

這種一字多拆的情況，任何形碼中，都是希望避免的。因為一字多拆，會造成極大的不確定性，並造成編碼的混亂。

前輩輸入法的拆字規則，一般都有諸如「直觀」、「符合筆順」、「取大」等設置。但是優先級往往不夠明確，很多拆分方法並不符合規則，存在不少特例。在常用字範圍內，還可以通過大量練習來完成記憶，但到了大字集，規則不明確、規則相矛盾，都是造成檢字困難的因素。

宇浩輸入法總結了拆字規則，並且不斷自我審視每一個拆分是否符合規則。通過大量的努力，明確了一套優先級系統。使每一個漢字，都有唯一的拆分方案，消除了不確定性。

當然，漢字不是完全可以量化的，不同字形下，也會出現不同的拆分可能。除了良好的定義外，有時候比例原則也很重要。尤其在大字集上，追求單一拆分方法會扭曲漢字直觀性，不能兼顧不同字形，讓使用者需要大量嘗試才能找到想要的字，這違背了大字集檢字的初衷。因此，對於大字集，也會設置兼容拆分和容錯碼。

::: info 拆字優先級

「宇浩」拆字規則，按優先級排序如下：

1. 字根最少
1. 符合筆順
1. 結構完整
1. 散連交斷
1. 字根取大

以上優先級，還可以高度歸納為：**少順整散連交斷大**。
:::

取根時，如果有多種不同的拆分方式，則按**優先級從高到低**依次檢查以上規則，選取符合條件的，排除不滿足的，最終得到唯一的拆分方案。因此，某種意義上來說，宇浩輸入法的拆分規則，其實是一種「比較和淘汰」的排除法，[後文中會展示這些步驟的機器實現](#機器實現)。

::: info 注意

在進行拆分前，首先需要「確認」某個字根到底存不存在，是否合規，也就是檢查字根的「內在屬性」。比如`土` `士`，兩橫的長度直接決定了字根的異同。  

其次需要檢查一些「拆分禁手」，比如`王`中間如果被筆畫「穿心」，這是不被允許的。禁手有：散件不分割、豎向不包夾、橫間不穿心。  

對這兩點的討論作為進階內容，於此處跳過。若有興趣，可以在後續章節 《進階討論》中閱讀。
:::

以下為拆分規則詳細介紹：

## 字根最少

字根最少，意思是拆分一個字時，應該使得字根的數量最少。保證字根數量最少，是第一優先級最高的規則。

## 符合筆順

符合筆順，指的是字根的每一筆，完全符合原漢字的筆順。我們要使得完全合筆順的字根儘量多。

符合筆順的優先級低於字根最少。

::: tip 例

`國`如果完全符合筆順，應該拆成`冂王丶一`，是四個字根。但拆成`囗王丶`，只用三個字根就夠了。因為「少」優先級高於「順」，所以應該拆成`囗王丶`。
:::

## 結構完整

結構完整，指的是`囗日目勹冂匚コ凵`等存在全包圍和半包圍結構的字根不拆散。

這個原則的設置，是為了不過分破壞漢字的整體性和直觀性。

::: tip 例

`昜`拆`日一勹彡`不拆`日丆𠃌彡`。

`萬`拆成`一勹`而非`{一丿}乛`。

`單`可以拆成`丷日十`也可以拆成`丷冂豐`。兩者都是三根，都完全「符合筆順」。因為包圍結構不拆散，故而`單`拆成`丷日十`。

`免`可以拆成`⺈口兒`也可以拆成`⺈冂尢`。兩者都是三根，都完全「符合筆順」。因為包圍結構不拆散，故而`免`拆成`⺈口兒`。
:::

注意，拆分的優先級需要得到貫徹。

::: tip 例

`匹`拆`兀乚`而不拆`匚兒`。因為前者完全符合筆順，而「符合筆順」的優先級更高。
:::

## 散連交斷

「散·連·交·斷」，是漢字部首或筆畫的四種狀態。

- 字根離散，指的是兩個字根互相分離。比如`部`中的`立口阝`，便是三個分離的字根。
- 字根相連，指的是兩個字根互相連接。比如`美`拆為`𦍌大`，這兩個字根是相連的。
- 字根相交，指的是兩個字根互相交叉。比如`再`拆成`王冂`兩個字根，便是相交的。
- 筆劃斷開，指的是一個筆劃斷開。比如`我`拆成`丿扌戈`三個字根，其中的`扌`和`戈`兩根的橫本是一筆寫成，但我們將橫畫斷開。

「散連交斷」，優先級依次下降，但都排在「字根最少」「符合筆順」「結構完整」之後。

::: tip 例
`蘭`可以拆成`䒑二`也可以拆成`丷三`。觀察到，`䒑`的兩點是同一橫黏在一起的。拆成`丷三`，則兩個字根相連，拆成`䒑二`則兩個字根分散。後者符合「能散不連」。  

`開`可以拆成`一廾`也可以拆成`二{介下}`。觀察到，第一種拆法字根相連，第二種拆法字根相交。故而拆成`一廾`符合「能連不交」。  

`果`拆作`日木`，不拆成`田木`，這是因為後者將中間的豎斷開了。因為「字根相交」的優先級高於「筆畫斷開」，`果`應當拆成`日木`。  

`我`拆作`丿扌戈`，不拆成`丿扌乚丿丶`。雖然前者將中間的橫斷開了，但因為「字根最少」的優先級大於「筆畫斷開」，我們選擇只有三根的`丿扌戈`。  

`燻`拆作`千黑`，不拆成`千囗丷二灬`。雖然前者將中間的豎斷開了，但因為「字根最少」的優先級大於「筆畫斷開」，我們選擇只有兩根的`千黑`。  
:::

## 字根取大

字根取大，指的是按照筆順拆字時：

- 讓完全符合筆順的字根儘可能地大。也就是就算做不到完全合筆順，也要做到局部合筆順。只要其中某個字根多寫一筆仍然符合筆順，就多寫一筆。
- 讓非歪斜根儘可能地大。
- 讓首筆靠前的字根儘可能地大。

第一條的存在，是為了防止筆畫過於交織而導致拆分方案不直觀。

::: tip 例
這裡以`妻`字舉例，`妻`可以拆分為`十彐女``キコ女`甚至`龶乛女`。我們按順序檢查規則，發現：

- 三者都是三根，都不完全符合筆順，都存在相交。
- 我們最後檢查「字根取大」規則。我們發現，前兩個字根是穿插書寫的。`キコ女`的拆法中，前兩根分成四部分寫成。`十彐女``龶乛女`，前兩根只分成三部分寫成，故而`キコ女`淘汰。
- `十彐女`中，完全合筆順的字根`彐`寫了三筆。而`龶乛女`中，完全合筆順的字根`乛`只有一筆。
- `十彐女`勝出。
:::

第二條只有一種場合會出現，那就是部分字根在做偏旁的時候，由於書法的考慮，會有「豎變撇」的變化。如：`千`字根的`丨`變成`丿`，`幹`字根的`丨`變成`丿`，稱為「歪斜根」。我們應當對非歪斜根取大。

::: tip 例
`失`拆`丿夫`而不拆`牛乀`，因為`牛`的一豎是撇。故而對`夫`取大。

`井`拆`二{介下}`而不拆`キ丨`，因為因為`キ`的一豎是撇。故而對`{介下}`取大。

`緩`拆`糹爪幹又`而不拆`糹爪二夂`。雖然前者`幹`的豎是撇，但後者出現了「字根相交」。根據規則優先級，「字根相交」低於「字根相連」，故而拆為`糹爪幹又`。
:::

第三條最為常見，「讓首筆靠前的字根儘可能地大」是一個兜底原則，可以保證最終只有一個候選方案能夠勝出。因此，它的優先級必然是所有拆字規則中最低的。

::: tip 例
`井`拆成`二{齊下}`，而不拆成`一廾`，因為「字根取大」原則。讓首筆靠前的字根的筆劃數儘量地多，這裡，`二`的筆畫數大於`一`。  

`美`拆為`䒑土大`，而不拆成`丷王大`，因為「字根取大」原則。讓首筆靠前的字根的筆劃數儘量地多，這裡，`䒑`的筆畫數大於`丷`。
:::

## 拆字舉例

實際拆字時，如果你感覺拆分方法不唯一，那麼可以用以下方法找到最優解：

- 列出所有可能的候選拆分方案。
- 依照「少順整散連交斷大」的規則順序，依次比較各個候選拆分。
- 如果所有的候選拆分都不滿足本條規則，則進入下條規則。
- 如果部分的候選拆分滿足本條規則，則該部分的候選拆分方案進入下條規則。
- 直到只有一個候選拆分方案勝出。

以下通過部分例字來說明拆分規則：

::: tip 例

1. 一例：亷。候選拆分`亠丷廠彐〢八`和`立丿彐〢八`。
   - `亠丷廠彐〢八`六根，`立丿彐〢八`五根。後者字根最少，直接勝出。
2. 又一例：重。候選拆分`丿車一`和`千里`。
   - `千里`是兩根，滿足「字根最少」，直接雖然中間一豎斷開，但依然勝出。
3. 又一例：盡。候選拆分`コ土灬皿``乛龶灬皿``彐丄灬皿``{聿上}一灬皿`四種。
   - 都是四根，同時滿足「字根最少」。
   - `コ土灬皿`不符合筆順，其他三者都完全符合筆順。淘汰`コ土灬皿`。
   - 上半部分都出現字根相交情況。
   - 都不適用「結構合理」。
   - 進入兜底規則「字根取大」。根據規則，只要其中某個字根多寫一筆仍然符合筆順，就多寫一筆。觀察到，`{聿上}一灬皿`的第一根一共寫了四筆，故而勝出。
4. 又一例：曱 yuē甴 yóu。
   - `曱`按筆順取大，故而是`日丨`。
   - `甴`，候選拆分為`日丨``囗丄`。兩者都是兩根，都未破壞包圍結構，都出現了「交」。最後查看取大原則。因為先寫豎，再寫中間的一橫，為了讓完全符合筆順的部件儘可能地大，我們取`丄`。最後`囗丄`勝出。
:::

上面的例子邏輯雖比較複雜，但是最終的結果還是非常直觀的。在宇浩輸入法中，大多數的時候，直觀的拆分方法往往也是符合規則的。

## 機器實現

這裡釋出宇浩拆分規則的偽代碼，用以展示使用計算機程序來實現拆分篩選的算法邏輯。注意，宇浩的拆分規則是**淘汰性**而非**引導性**的，故而算法的前置條件是已經擁有了若干的候選拆分，在此基礎上，程序可以篩選出最滿足宇浩拆分規則的唯一拆分。

假設某個漢字存在`N`個候選拆分，記為 `divs = {div_i | i in [1, 2, ..., N]}`。每個拆分都是字根的**有序**集合，記為 `div = {root_i | i in [1, 2, ..., M]}`，有以下屬性：

- `div.len: int` 字根個數
- `div.bishun: Booleann` 字根是否完全合筆順
- `div.san: Boolean` 字根是否分散
- `div.lian: Boolean` 字根是否相連
- `div.jiao: Boolean` 字根是否相交
- `div.duan: Boolean` 字根是否斷開

注意：`div.san`, `div.lian`, `div.jiao`, `div`,`duan` 中有且只有一個是 `True`。

以下偽代碼會從`N`個候選拆分`divs = {div_i | i in [1, 2, ..., N]}` 中選出最優拆分：

```python
# 字根最少
for div_i in divs:
    # 移除字根數量不是最少的候選拆分
    if div_i.len != min([i.len for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 符合筆順
for div_i in divs:
    # 存在完全符合筆順的拆分時，移除不完全符合筆順的候選拆分
    if div_i.bishun != max([i.bishun for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 結構完整
root_completeness_score = {
    囗：2,
    日：2,
    目：2,
    田：2,
    冂：1,
    勹：1,
    匚：1,
    凵：1,
    コ：1,
    其他：0,
}  # 包圍結構得分更高
for div_i, div_j in permutation(divs, 2):  # 倆倆取候選拆分比較
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # 非共同字根中有包圍結構的保留
    if unique_i.map(root_completeness_score) < unique_j.map(root_completeness_score):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 字根分散
for div_i in divs:
    # 存在散的拆分時，移除不散的候選拆分
    if div_i.san != max([i.san for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 字根相連
for div_i in divs:
    # 存在連的拆分時，移除不連的候選拆分
    if div_i.lian != max([i.lian for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 字根相交
for div_i in divs:
    # 存在交的拆分時，移除不交的候選拆分
    if div_i.jiao != max([i.jiao for i in divs]):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 字根斷開
# 斷屬性為散連交的補集，故不用再進行判斷

# 字根取大之一
# 讓完全符合筆順的部件儘可能地大
for div_i, div_j in permutation(divs, 2):  # 倆倆取候選拆分比較
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # root_bishun_score(div) 是局部拆分中完全符合筆順的字根數量
    # 非共同字根中，完全符合筆順的字根數量多的保留
    if root_bishun_score(unique_i) < root_bishun_score(unique_j):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 字根取大之二
# 讓非歪斜根儘可能地大
for div_i, div_j in permutation(divs, 2):  # 倆倆取候選拆分比較
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # leaning_root_strokes(div) 是局部拆分中歪斜根的筆畫數
    # 非共同字根中，非歪斜根筆畫多的保留
    if leaning_root_strokes(unique_i) > leaning_root_strokes(unique_j):
        divs.remove(div_i)
    if len(divs) == 1:
        break  # 剩下唯一拆分候選，則停止判斷

# 字根取大之三
# 讓首筆靠前的字根儘可能地大
for div_i, div_j in permutation(divs, 2):  # 倆倆取候選拆分比較
    common = intersect(div_i, div_j)  # 共同的拆分部分
    unique_i = div_i.difference(common)  # 非共同的拆分部分
    unique_j = div_j.difference(common)  # 非共同的拆分部分
    # root_i.strokes.len 是字根的筆畫數
    # 非共同字根中，靠前的字根筆畫多的保留
    for root_i, root_j in zip(unique_i, unique_j):  # 倆倆取字根比較
        if root_i.strokes.len < root_j.strokes.len:
            divs.remove(div_i)

# 到此，必然只剩下唯一的拆分候選，即為最終拆分
```
